<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 MPU6050 Head Impact Monitor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
    <style>
        body { 
            font-family: 'Inter', sans-serif; 
            background-color: #121212; 
            color: #e0e0e0; 
        }
        .modal { 
            display: none; 
            position: fixed; 
            z-index: 100; 
            left: 0; 
            top: 0; 
            width: 100%; 
            height: 100%; 
            overflow: auto; 
            background-color: rgba(0,0,0,0.7); 
            backdrop-filter: blur(5px); 
        }
        .modal-content { 
            background-color: #1f1f1f; 
            margin: 15% auto; 
            padding: 24px; 
            border-radius: 12px; 
            box-shadow: 0 10px 15px rgba(0,0,0,0.3); 
            max-width: 500px; 
            animation: fadeIn 0.3s ease-in-out; 
            color: #e0e0e0; 
        }
        .close-button { 
            color: #888; 
            float: right; 
            font-size: 28px; 
            font-weight: bold; 
        }
        .close-button:hover, .close-button:focus { 
            color: #ccc; 
            text-decoration: none; 
            cursor: pointer; 
        }
        @keyframes fadeIn { 
            from { opacity: 0; transform: translateY(-20px); } 
            to { opacity: 1; transform: translateY(0); } 
        }
        .live-feed-box { 
            background-color: #2c2c2c; 
            color: #a0a0a0; 
            font-family: 'Courier New', Courier, monospace; 
            height: 200px; 
            overflow-y: scroll; 
        }
        .hidden { 
            display: none; 
        }
        .data-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1.5rem;
        }
        @media (max-width: 1280px) {
            .data-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        @media (max-width: 768px) {
            .data-grid {
                grid-template-columns: 1fr;
            }
        }
        .risk-level {
            font-weight: bold;
            padding: 0.25rem 0.5rem;
            border-radius: 0.375rem;
            display: inline-block;
            font-size: 0.875rem;
        }
        .risk-low { background-color: #16a34a; color: white; }
        .risk-moderate { background-color: #ca8a04; color: white; }
        .risk-high { background-color: #c2410c; color: white; }
        .risk-severe { background-color: #991b1b; color: white; }

        /* Tooltip Styling */
        .tooltip-container {
            position: relative;
            display: inline-block;
        }
        .tooltip-text {
            visibility: hidden;
            width: 220px;
            background-color: #333;
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 8px;
            position: absolute;
            z-index: 1000;
            bottom: 125%;
            left: 50%;
            margin-left: -110px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.85rem;
            line-height: 1.4;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            font-weight: normal;
        }
        .tooltip-container:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
    </style>
</head>
<body class="bg-gray-900 min-h-screen flex flex-col items-center p-4 sm:p-8">
    <div class="max-w-6xl w-full flex flex-col gap-6">
        <h1 class="text-3xl font-bold text-center text-gray-100 mb-4">Head Impact Monitor</h1>
        <p id="status-message" class="text-center text-sm text-gray-400">
            Please connect to your ESP32 device to start receiving data.
        </p>
        <div class="flex flex-col sm:flex-row justify-center items-center gap-4">
            <button id="connectButton" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-full shadow-lg transition duration-300 transform hover:scale-105">
                Connect to ESP32
            </button>
            <button id="zeroButton" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-full shadow-lg transition duration-300 transform hover:scale-105 hidden">
                Zero Sensors
            </button>
        </div>

        <!-- Head Impact Risk Dashboard -->
        <div id="risk-dashboard" class="bg-gray-800 p-6 rounded-xl shadow-xl"> <!-- Always visible -->
            <h2 class="text-lg font-semibold text-gray-200 mb-4">Head Impact Risk Assessment</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div class="bg-gray-700 p-4 rounded-lg tooltip-container">
                    <h3 class="text-md font-semibold text-gray-300">Neurological Risk Score (NRS)</h3>
                    <p id="nrs-score" class="text-3xl font-bold text-gray-100 mt-2">0.0</p>
                    <p id="nrs-level" class="risk-level risk-low mt-1">Low Risk</p>
                    <div class="tooltip-text">
                        <strong>NRS:</strong> Composite risk score combining acute impact severity, recent exposure (AWE), and chronic load (CLI). Triggers alerts at high levels.
                    </div>
                </div>
                <div class="bg-gray-700 p-4 rounded-lg tooltip-container">
                    <h3 class="text-md font-semibold text-gray-300">Latest Impact</h3>
                    <p class="text-sm text-gray-300 mt-2">None detected</p>
                    <p id="latest-impact" class="text-sm font-mono text-gray-100"></p>
                    <div class="tooltip-text">
                        <strong>Latest Impact:</strong> Details of the most recent detected head impact: severity (ISS), linear acceleration (g), and rotational acceleration (rad/sÂ²).
                    </div>
                </div>
                <div class="bg-gray-700 p-4 rounded-lg tooltip-container">
                    <h3 class="text-md font-semibold text-gray-300">Acute Exposure (AWE)</h3>
                    <p id="awe-score" class="text-xl font-bold text-yellow-300">0.0</p>
                    <div class="tooltip-text">
                        <strong>AWE:</strong> Acute Weighted Exposure. Rolling 7-day sum of impact severity, exponentially decayed. Reflects recent impact burden.
                    </div>
                </div>
                <div class="bg-gray-700 p-4 rounded-lg tooltip-container">
                    <h3 class="text-md font-semibold text-gray-300">Chronic Load (CLI)</h3>
                    <p id="cli-score" class="text-xl font-bold text-blue-300">0.0</p>
                    <div class="tooltip-text">
                        <strong>CLI:</strong> Chronic Load Index. Long-term average impact severity, low-pass filtered. Reflects cumulative exposure over the season.
                    </div>
                </div>
            </div>
            <div class="mt-6 h-60">
                <canvas id="nrsChartCanvas"></canvas>
            </div>
        </div>

        <!-- Live Graphs -->
        <div class="grid grid-cols-1 xl:grid-cols-2 gap-6">
            <div class="bg-gray-800 p-6 rounded-xl shadow-xl">
                <h2 class="text-lg font-semibold text-gray-200 mb-4">Accelerometer (Average)</h2>
                <div class="relative h-80">
                    <canvas id="accelChartCanvas"></canvas>
                </div>
            </div>
            <div class="bg-gray-800 p-6 rounded-xl shadow-xl">
                <h2 class="text-lg font-semibold text-gray-200 mb-4">Gyroscope (Average)</h2>
                <div class="relative h-80">
                    <canvas id="gyroChartCanvas"></canvas>
                </div>
            </div>
        </div>

        <!-- Debug Panel -->
        <details class="bg-gray-800 p-6 rounded-xl shadow-xl open">
            <summary class="text-lg font-semibold text-gray-200 cursor-pointer select-none">
                Debug Information
            </summary>
            <div class="mt-4 flex flex-col gap-6">
                <div id="data-container" class="data-grid">
                    <!-- Sensor cards (unchanged) -->
                    <!-- ... -->
                </div>
                <div class="bg-gray-700 p-6 rounded-xl shadow-xl">
                    <h2 class="text-lg font-semibold text-gray-200 mb-2">Live Data Feed (JSON)</h2>
                    <pre id="live-feed" class="live-feed-box p-4 rounded-xl text-xs overflow-auto"></pre>
                </div>
            </div>
        </details>

        <!-- Alert Modal -->
        <div id="alert-modal" class="modal">
            <div class="modal-content">
                <span class="close-button" onclick="document.getElementById('alert-modal').style.display='none'">&times;</span>
                <h3 class="text-xl font-bold mb-2">Alert</h3>
                <p id="alert-message" class="text-gray-300 whitespace-pre-line"></p>
            </div>
        </div>
    </div>

    <script>
        // === Custom Alert ===
        function showCustomAlert(message) {
            const modal = document.getElementById('alert-modal');
            const alertMessage = document.getElementById('alert-message');
            alertMessage.textContent = message;
            modal.style.display = 'block';
        }

        // === BLE Configuration ===
        const SERVICE_UUID = "12345678-1234-1234-1234-123456789abc";
        const CHARACTERISTIC_UUID = "87654321-4321-4321-4321-cba987654321";
        const DEVICE_NAME = "ESP32_MPU6050_BLE";

        // === DOM Elements ===
        const connectButton = document.getElementById('connectButton');
        const zeroButton = document.getElementById('zeroButton');
        const statusMessage = document.getElementById('status-message');
        const liveFeed = document.getElementById('live-feed');

        const sensorDisplays = {};
        for (let i = 1; i <= 4; i++) {
            sensorDisplays[`s${i}`] = {
                accel: {
                    x: document.getElementById(`s${i}_accelX`),
                    y: document.getElementById(`s${i}_accelY`),
                    z: document.getElementById(`s${i}_accelZ`)
                },
                gyro: {
                    x: document.getElementById(`s${i}_gyroX`),
                    y: document.getElementById(`s${i}_gyroY`),
                    z: document.getElementById(`s${i}_gyroZ`)
                }
            };
        }

        // Risk Dashboard Elements
        const nrsScoreEl = document.getElementById('nrs-score');
        const nrsLevelEl = document.getElementById('nrs-level');
        const latestImpactEl = document.getElementById('latest-impact');
        const aweScoreEl = document.getElementById('awe-score');
        const cliScoreEl = document.getElementById('cli-score');

        // === BLE State ===
        let bleDevice;
        let bleCharacteristic;

        // === Data Constants ===
        const SMOOTHING_WINDOW_SIZE = 7;
        const VISIBLE_DATA_POINTS = 500;
        const dataPointsPerSecond = 100;
        const Y_BUFFER_PERCENTAGE = 0.05;
        const MIN_Y_RANGE = 3;

        // History Buffers
        let accelHistory = { s1: { x: [], y: [], z: [] }, s2: { x: [], y: [], z: [] }, s3: { x: [], y: [], z: [] }, s4: { x: [], y: [], z: [] } };
        let gyroHistory = { s1: { x: [], y: [], z: [] }, s2: { x: [], y: [], z: [] }, s3: { x: [], y: [], z: [] }, s4: { x: [], y: [], z: [] } };

        // Sensor Offsets
        let offsets = {
            s1: { accel: { x: 0, y: 0, z: 9.81 }, gyro: { x: 0, y: 0, z: 0 } },
            s2: { accel: { x: 0, y: 0, z: 9.81 }, gyro: { x: 0, y: 0, z: 0 } },
            s3: { accel: { x: 0, y: 0, z: 9.81 }, gyro: { x: 0, y: 0, z: 0 } },
            s4: { accel: { x: 0, y: 0, z: 9.81 }, gyro: { x: 0, y: 0, z: 0 } }
        };

        // === Impact & Risk Variables ===
        const IMPACT_THRESHOLD = 0.05;
        const DEAD_TIME_MS = 1000; // Extended from 50ms to 1000ms
        let lastImpactTime = 0;
        let impactHistory = [];
        let cli = 0.0;
        const CLI_DECAY = 0.99;
        const AWE_DECAY_RATE = 0.4;
        let lastGyro = { s1: 0, s2: 0, s3: 0, s4: 0 };

        // === NRS Chart ===
        const nrsCtx = document.getElementById('nrsChartCanvas').getContext('2d');
        const nrsChart = new Chart(nrsCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'NRS',
                    data: [],
                    borderColor: 'rgba(255, 99, 132, 1)',
                    backgroundColor: 'rgba(255, 99, 132, 0.2)',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.3
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                plugins: {
                    tooltip: {
                        callbacks: {
                            title: () => '',
                            label: (context) => {
                                const nrs = context.parsed.y;
                                const time = context.chart.data.labels[context.dataIndex] || 'Now';
                                return [
                                    `NRS: ${nrs.toFixed(1)}`,
                                    `Time: ${time}`,
                                    `AWE: ${aweScoreEl.textContent}`,
                                    `CLI: ${cliScoreEl.textContent}`
                                ];
                            }
                        }
                    },
                    legend: { labels: { color: '#e0e0e0' } }
                },
                scales: {
                    x: {
                        display: false // Hide X-axis labels (time)
                    },
                    y: {
                        min: 0, max: 10,
                        title: { display: true, text: 'NRS', color: '#a0a0a0' },
                        ticks: { color: '#e0e0e0' },
                        grid: { color: 'rgba(255,255,255,0.1)' }
                    }
                }
            }
        });

        // === Chart Setup (Accelerometer & Gyroscope) ===
        function createChart(ctx, labelPrefix, yAxisLabel) {
            return new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        { label: `${labelPrefix} X`, borderColor: 'rgb(239, 68, 68)', backgroundColor: 'rgba(239, 68, 68, 0.2)', data: [], tension: 0.4 },
                        { label: `${labelPrefix} Y`, borderColor: 'rgb(59, 130, 246)', backgroundColor: 'rgba(59, 130, 246, 0.2)', data: [], tension: 0.4 },
                        { label: `${labelPrefix} Z`, borderColor: 'rgb(16, 185, 129)', backgroundColor: 'rgba(16, 185, 129, 0.2)', data: [], tension: 0.4 }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    interaction: { mode: 'index', intersect: false },
                    plugins: {
                        legend: { labels: { usePointStyle: true, boxWidth: 8, padding: 16, color: '#e0e0e0' } },
                        tooltip: {
                            callbacks: {
                                title: (items) => `Time: ${items[0].label}`,
                                label: (item) => `${item.dataset.label}: ${item.parsed.y.toFixed(2)}`
                            }
                        }
                    },
                    scales: {
                        x: {
                            display: false // Hide time on X-axis
                        },
                        y: {
                            title: { display: true, text: yAxisLabel, color: '#a0e0e0' },
                            min: -MIN_Y_RANGE, max: MIN_Y_RANGE,
                            ticks: { stepSize: 1, color: '#e0e0e0' },
                            grid: { color: (ctx) => ctx.tick.value === 0 ? 'rgba(255,255,255,0.7)' : 'rgba(255,255,255,0.1)', lineWidth: (ctx) => ctx.tick.value === 0 ? 2 : 1 }
                        }
                    },
                    elements: { point: { radius: 0 } }
                }
            });
        }

        const accelChart = createChart(document.getElementById('accelChartCanvas').getContext('2d'), 'Accel', 'm/sÂ²');
        const gyroChart = createChart(document.getElementById('gyroChartCanvas').getContext('2d'), 'Gyro', 'rad/s');

        // === Auto-Zeroing (Continuous, No Delay) ===
        const AUTO_ZERO_ENABLED = true;
        const AUTO_ZERO_ALPHA = 0.01;

        // === Zeroing Logic (Unchanged structure, but used conditionally) ===
        const ZEROING_SAMPLES = 25;
        let zeroingSampleCount = 0;
        let zeroingSamples = {
            s1: { accel: { x: [], y: [], z: [] }, gyro: { x: [], y: [], z: [] } },
            s2: { accel: { x: [], y: [], z: [] }, gyro: { x: [], y: [], z: [] } },
            s3: { accel: { x: [], y: [], z: [] }, gyro: { x: [], y: [], z: [] } },
            s4: { accel: { x: [], y: [], z: [] }, gyro: { x: [], y: [], z: [] } }
        };
        let isZeroing = false;

        function startZeroing() {
            if (isZeroing) return;
            isZeroing = true;
            zeroingSampleCount = 0;
            zeroingSamples = {
                s1: { accel: { x: [], y: [], z: [] }, gyro: { x: [], y: [], z: [] } },
                s2: { accel: { x: [], y: [], z: [] }, gyro: { x: [], y: [], z: [] } },
                s3: { accel: { x: [], y: [], z: [] }, gyro: { x: [], y: [], z: [] } },
                s4: { accel: { x: [], y: [], z: [] }, gyro: { x: [], y: [], z: [] } }
            };
            zeroButton.disabled = true;
            zeroButton.textContent = 'Zeroing...';
            statusMessage.textContent = 'Manual zeroing in progress...';
        }

        function calculateNewOffsets(sensorData) {
            if (!isZeroing) return;
            for (let i = 1; i <= 4; i++) {
                const key = `sensor${i}`;
                const s = `s${i}`;
                ['x','y','z'].forEach(ax => {
                    zeroingSamples[s].accel[ax].push(sensorData[key].accel[ax]);
                    zeroingSamples[s].gyro[ax].push(sensorData[key].gyro[ax]);
                });
            }
            zeroingSampleCount++;
            statusMessage.textContent = `Zeroing... ${zeroingSampleCount}/${ZEROING_SAMPLES}`;
            if (zeroingSampleCount >= ZEROING_SAMPLES) {
                isZeroing = false;
                zeroButton.disabled = false;
                zeroButton.textContent = 'Zero Sensors';
                statusMessage.textContent = 'Manual zeroing complete.';
                for (let i = 1; i <= 4; i++) {
                    const s = `s${i}`;
                    const avg = arr => arr.reduce((a,b) => a+b, 0) / arr.length;
                    offsets[s].accel.x = avg(zeroingSamples[s].accel.x);
                    offsets[s].accel.y = avg(zeroingSamples[s].accel.y);
                    offsets[s].accel.z = avg(zeroingSamples[s].accel.z);
                    offsets[s].gyro.x = avg(zeroingSamples[s].gyro.x);
                    offsets[s].gyro.y = avg(zeroingSamples[s].gyro.y);
                    offsets[s].gyro.z = avg(zeroingSamples[s].gyro.z);
                }
            }
        }

        // === Impact Detection ===
        function detectImpact(sensorData, a, g, sensorId) {
            const now = Date.now();
            if (now - lastImpactTime < DEAD_TIME_MS) return;

            const a_mag_mss = Math.sqrt(a.x**2 + a.y**2 + a.z**2);
            const a_mag_g = a_mag_mss / 9.81;
            const omega_mag = Math.sqrt(g.x**2 + g.y**2 + g.z**2);
            const alpha_mag = (omega_mag - (lastGyro[sensorId] || 0)) / 0.01;
            lastGyro[sensorId] = omega_mag;

            if (a_mag_g < 1.5 || Math.abs(alpha_mag) < 100) return;

            const whise = 0.4 * (a_mag_g / 100) + 0.6 * (Math.abs(alpha_mag) / 6000);
            if (whise >= IMPACT_THRESHOLD) {
                lastImpactTime = now;
                const iss = Math.log10(1 + a_mag_g) * (1 + Math.abs(alpha_mag) / 5000) * 1.3;
                const impact = {
                    time: now,
                    sensor: sensorId,
                    a_peak: a_mag_g,
                    alpha_peak: Math.abs(alpha_mag),
                    iss: parseFloat(iss.toFixed(2))
                };
                impactHistory.push(impact);
                processImpact(impact);
            }
        }

        // === Risk Scoring Engine ===
        function processImpact(impact) {
            cli = CLI_DECAY * cli + (1 - CLI_DECAY) * impact.iss;
            const now = Date.now();
            const oneDay = 24*60*60*1000;
            impactHistory = impactHistory.filter(imp => (now - imp.time) < 7 * oneDay);
            let awe = 0;
            impactHistory.forEach(imp => {
                const daysAgo = (now - imp.time) / oneDay;
                awe += imp.iss * Math.exp(-AWE_DECAY_RATE * daysAgo);
            });

            const nrs = 0.5 * impact.iss + 0.3 * awe + 0.2 * cli;
            const nrsRounded = Math.round(nrs * 10) / 10;

            nrsScoreEl.textContent = nrsRounded.toFixed(1);
            latestImpactEl.textContent = `ISS: ${impact.iss}, A: ${impact.a_peak.toFixed(1)}g, R: ${impact.alpha_peak.toFixed(0)} rad/sÂ²`;

            if (nrsRounded < 3) {
                nrsLevelEl.className = 'risk-level risk-low'; nrsLevelEl.textContent = 'Low Risk';
            } else if (nrsRounded < 6) {
                nrsLevelEl.className = 'risk-level risk-moderate'; nrsLevelEl.textContent = 'Moderate';
            } else if (nrsRounded < 8) {
                nrsLevelEl.className = 'risk-level risk-high'; nrsLevelEl.textContent = 'High - Evaluate';
                showCustomAlert(`High Risk Detected!\nNRS: ${nrsRounded}\nSideline assessment recommended.`);
            } else {
                nrsLevelEl.className = 'risk-level risk-severe'; nrsLevelEl.textContent = 'Severe - Stop';
                showCustomAlert(`SEVERE IMPACT!\nNRS: ${nrsRounded}\nImmediate medical evaluation required.`);
            }

            aweScoreEl.textContent = awe.toFixed(2);
            cliScoreEl.textContent = cli.toFixed(2);

            nrsChart.data.labels.push(new Date().toLocaleTimeString());
            nrsChart.data.datasets[0].data.push(nrsRounded);
            if (nrsChart.data.labels.length > 100) {
                nrsChart.data.labels.shift();
                nrsChart.data.datasets[0].data.shift();
            }
            nrsChart.update('none');
        }

        // === Main Data Handler ===
        function handleCharacteristicValueChanged(event) {
            const value = event.target.value;
            const decoder = new TextDecoder('utf-8');
            const receivedString = decoder.decode(value);
            liveFeed.textContent = receivedString;
            liveFeed.scrollTop = liveFeed.scrollHeight;

            try {
                const sensorData = JSON.parse(receivedString);

                if (isZeroing) {
                    calculateNewOffsets(sensorData);
                }

                const accelAvg = { x: 0, y: 0, z: 0 };
                const gyroAvg = { x: 0, y: 0, z: 0 };

                for (let i = 1; i <= 4; i++) {
                    const key = `sensor${i}`;
                    const s = `s${i}`;
                    const rawA = sensorData[key].accel;
                    const rawG = sensorData[key].gyro;

                    const smoothedA = smoothData(rawA, accelHistory[s]);
                    const smoothedG = smoothData(rawG, gyroHistory[s]);

                    // === Auto-Zero: Continuous offset adaptation ===
                    if (AUTO_ZERO_ENABLED && !isZeroing) {
                        offsets[s].accel.x += AUTO_ZERO_ALPHA * (smoothedA.x - offsets[s].accel.x);
                        offsets[s].accel.y += AUTO_ZERO_ALPHA * (smoothedA.y - offsets[s].accel.y);
                        offsets[s].accel.z += AUTO_ZERO_ALPHA * (smoothedA.z - offsets[s].accel.z);

                        offsets[s].gyro.x += AUTO_ZERO_ALPHA * (smoothedG.x - offsets[s].gyro.x);
                        offsets[s].gyro.y += AUTO_ZERO_ALPHA * (smoothedG.y - offsets[s].gyro.y);
                        offsets[s].gyro.z += AUTO_ZERO_ALPHA * (smoothedG.z - offsets[s].gyro.z);
                    }

                    const zeroedA = {
                        x: smoothedA.x - offsets[s].accel.x,
                        y: smoothedA.y - offsets[s].accel.y,
                        z: smoothedA.z - offsets[s].accel.z
                    };
                    const zeroedG = {
                        x: smoothedG.x - offsets[s].gyro.x,
                        y: smoothedG.y - offsets[s].gyro.y,
                        z: smoothedG.z - offsets[s].gyro.z
                    };

                    sensorDisplays[s].accel.x.textContent = zeroedA.x.toFixed(2);
                    sensorDisplays[s].accel.y.textContent = zeroedA.y.toFixed(2);
                    sensorDisplays[s].accel.z.textContent = zeroedA.z.toFixed(2);
                    sensorDisplays[s].gyro.x.textContent = zeroedG.x.toFixed(2);
                    sensorDisplays[s].gyro.y.textContent = zeroedG.y.toFixed(2);
                    sensorDisplays[s].gyro.z.textContent = zeroedG.z.toFixed(2);

                    accelAvg.x += zeroedA.x;
                    accelAvg.y += zeroedA.y;
                    accelAvg.z += zeroedA.z;
                    gyroAvg.x += zeroedG.x;
                    gyroAvg.y += zeroedG.y;
                    gyroAvg.z += zeroedG.z;

                    detectImpact(sensorData, zeroedA, zeroedG, s);
                }

                if (!isZeroing) statusMessage.textContent = 'Receiving live data...';

                function updateChart(chart, x, y, z) {
                    chart.data.datasets[0].data.push(x);
                    chart.data.datasets[1].data.push(y);
                    chart.data.datasets[2].data.push(z);
                    chart.data.labels.push(new Date().toLocaleTimeString());

                    const all = [...chart.data.datasets[0].data, ...chart.data.datasets[1].data, ...chart.data.datasets[2].data];
                    const max = Math.max(...all.map(Math.abs));
                    const scale = Math.max(max * (1 + Y_BUFFER_PERCENTAGE), MIN_Y_RANGE);
                    chart.options.scales.y.min = -scale;
                    chart.options.scales.y.max = scale;

                    if (chart.data.datasets[0].data.length > VISIBLE_DATA_POINTS) {
                        chart.data.datasets.forEach(d => d.data.shift());
                        chart.data.labels.shift();
                    }
                    chart.update('none');
                }

                updateChart(accelChart, accelAvg.x/4, accelAvg.y/4, accelAvg.z/4);
                updateChart(gyroChart, gyroAvg.x/4, gyroAvg.y/4, gyroAvg.z/4);
            } catch (e) {
                console.error("Parse error:", e);
                showCustomAlert("Invalid JSON: " + receivedString);
            }
        }

        // === BLE Connection ===
        function onDisconnected() {
            statusMessage.textContent = 'Disconnected. Click connect to retry.';
            connectButton.textContent = 'Connect to ESP32';
            connectButton.disabled = false;
            connectButton.classList.remove('bg-green-600', 'hover:bg-green-700');
            connectButton.classList.add('bg-blue-600', 'hover:bg-blue-700');
            zeroButton.classList.add('hidden');
            isZeroing = false;
        }

        async function connectToBle() {
            try {
                connectButton.textContent = 'Connecting...';
                connectButton.disabled = true;
                statusMessage.textContent = 'Finding device...';

                if (!navigator.bluetooth) throw new Error("Web Bluetooth not supported.");

                bleDevice = await navigator.bluetooth.requestDevice({
                    filters: [{ name: DEVICE_NAME }],
                    optionalServices: [SERVICE_UUID]
                });

                bleDevice.addEventListener('gattserverdisconnected', onDisconnected);
                const server = await bleDevice.gatt.connect();
                const service = await server.getPrimaryService(SERVICE_UUID);
                bleCharacteristic = await service.getCharacteristic(CHARACTERISTIC_UUID);
                await bleCharacteristic.startNotifications();
                bleCharacteristic.addEventListener('characteristicvaluechanged', handleCharacteristicValueChanged);

                statusMessage.textContent = 'Connected!';
                connectButton.textContent = 'Connected';
                connectButton.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                connectButton.classList.add('bg-green-600', 'hover:bg-green-700');
                zeroButton.classList.remove('hidden');
            } catch (error) {
                const msg = error.message || error.name;
                statusMessage.textContent = 'Failed: ' + (msg.includes('found') ? 'Device not found.' : 'Connection error.');
                connectButton.textContent = 'Connect';
                connectButton.disabled = false;
                connectButton.classList.remove('bg-green-600');
                connectButton.classList.add('bg-blue-600');
                showCustomAlert("BLE Error: " + msg);
            }
        }

        // === Event Listeners ===
        connectButton.addEventListener('click', connectToBle);
        zeroButton.addEventListener('click', startZeroing);

        window.onclick = (e) => {
            if (e.target.id === 'alert-modal') {
                document.getElementById('alert-modal').style.display = 'none';
            }
        };

        // === Smooth Data Function (must be after use) ===
        function smoothData(rawData, historyBuffer) {
            ['x','y','z'].forEach(axis => {
                historyBuffer[axis].push(rawData[axis]);
                if (historyBuffer[axis].length > SMOOTHING_WINDOW_SIZE) {
                    historyBuffer[axis].shift();
                }
            });
            const avg = (arr) => arr.reduce((a,b) => a+b, 0) / arr.length;
            return {
                x: avg(historyBuffer.x),
                y: avg(historyBuffer.y),
                z: avg(historyBuffer.z)
            };
        }
    </script>
</body>
</html>